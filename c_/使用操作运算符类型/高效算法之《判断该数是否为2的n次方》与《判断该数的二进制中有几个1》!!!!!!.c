#include <stdio.h>
#include <time.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>
#include <stdbool.h>

//判断一个数是否是2的n次方
void count_num_of_1(int n) {
	if ((n & (n - 1)) == 0) {
		printf("%d是2的n次方\n", n);;
	} else {
		printf("%d不是2的n次方\n", n);
	}

}
/*
关于2的次方数有一个特点 就是它的二进制里只含有一个1

假设输入整数 n = 8，其二进制表示为 1000。
现在我们来看看算法如何判断这个整数的二进制表示中是否只包含一个 1：
首先计算 n - 1，即 8 - 1 = 7，其二进制表示为 0111。
然后进行按位与运算：8 & 7，即 1000 & 0111 = 0000。
结果为 0，表示整数 8 的二进制表示中只包含一个 1 和若干个 0。
因此，对于输入整数 8，函数 count_num_of_1(8) 将输出“是”。
这个算法的核心思想是利用 (n & (n - 1)) == 0 这个条件来判断整数 n 的二进制表示中是否只包含一个 1。
如果该条件成立，说明整数 n 的二进制表示中只有一个 1，否则表示不止一个 1 或者没有 1。
*/


//判断该输的二进制有几个1
int  count_num_of_2(int n) {
	int cnt = 0;
	while (n != 0) {
		n = n & (n - 1);
		cnt++;
	}
	return cnt;
}
/*
我们以整数 25 为例，二进制表示为 11001。现在我们来详细展示代码中核心部分的执行过程：
初始时，n = 25，cnt = 0。
第一次循环：
n = 25 & (25 - 1) = 25 & 24 = 24，此时二进制表示为 11001 & 11000 = 11000，cnt = 1。
第二次循环：
n = 24 & (24 - 1) = 24 & 23 = 16，此时二进制表示为 11000 & 10111 = 10000，cnt = 2。
第三次循环：
n = 16 & (16 - 1) = 16 & 15 = 0，此时二进制表示为 10000 & 01111 = 00000，cnt = 3。
循环结束，返回 cnt 的值 3
*/

int main() {
	int i = 0;
	int num;
	scanf("%d", &n);

	for (i =30;i >=0;i-=2) {
		printf("%d ", (num >> i)&1);

	}
	printf("\n");

	for (i = 31;i >= 0;i -= 2) {
		printf("%d ", (num >> i)&1);

	}


	return 0;
}